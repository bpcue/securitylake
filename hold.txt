Tenant_Tables
---------------
# Build per-tenant table scopes

###############################################################################
# Derive per-tenant table scope (columns + row filters)
###############################################################################

locals {
  tenant_table_matrix = {
    for tenant_key, tenant_cfg in var.tenants :
    tenant_key => {
      for table_key, table_cfg in var.tables :
      table_key => merge(
        {
          allowed_columns = null
          row_filter_expression = length(local.tenant_accounts[tenant_key]) > 0 ? format("accountid IN (%s)", join(", ", [for acct in local.tenant_accounts[tenant_key] : format("'%s'", acct)])) : "accountid IS NULL"
        },
        lookup(
          coalesce(tenant_cfg.table_overrides, {}),
          table_key,
          {
            allowed_columns       = null
            row_filter_expression = null
          }
        )
      )
    }
  }

  tenant_table_pairs = flatten([
    for tenant_key, table_cfg in local.tenant_table_matrix : [
      for table_key, settings in table_cfg : {
        tenant_key            = tenant_key
        tenant                = var.tenants[tenant_key]
        table_key             = table_key
        database_name         = var.tables[table_key].database_name
        table_name            = var.tables[table_key].table_name
        allowed_columns       = lookup(settings, "allowed_columns", null)
        row_filter_expression = lookup(settings, "row_filter_expression", null)
      }
    ]
  ])

  tenant_table_objects = {
    for obj in local.tenant_table_pairs :
    "${obj.tenant_key}::${obj.table_key}" => obj
  }

  tenant_database_groups = {
    for obj in local.tenant_table_pairs :
    "${obj.tenant_key}::${obj.database_name}" => obj...
  }

  tenant_database_objects = {
    for key, objs in local.tenant_database_groups :
    key => {
      tenant_key    = objs[0].tenant_key
      tenant        = objs[0].tenant
      database_name = objs[0].database_name
    }
  }

  active_tables = {
    for table_key, table_cfg in var.tables :
    table_key => table_cfg
    if length([
      for tt in local.tenant_table_pairs : 1
      if tt.table_key == table_key
    ]) > 0
  }
}

Inventory
---------
# Load OU inventory from S3

###############################################################################
# Tenant OU inventory â€“ read pre-generated JSON from S3
###############################################################################

locals {
  tenant_s3_objects = var.enable_ou_inventory_lookup ? {
    for tenant_key, tenant_cfg in var.tenants :
    tenant_key => {
      bucket = var.ou_inventory_bucket
      key    = local.ou_inventory_prefix_clean != "" ? "${local.ou_inventory_prefix_clean}/${tenant_cfg.ou_id}.json" : "${tenant_cfg.ou_id}.json"
    }
  } : {}
}

data "aws_s3_object" "tenant_accounts" {
  for_each = var.manage_tenants && var.enable_ou_inventory_lookup ? local.tenant_s3_objects : {}
  provider = aws.security_lake
  bucket   = each.value.bucket
  key      = each.value.key
}

locals {
  tenant_accounts = {
    for tenant_key, tenant_cfg in var.tenants :
    tenant_key => sort(distinct(concat(
      (var.manage_tenants && var.enable_ou_inventory_lookup) ? try(jsondecode(data.aws_s3_object.tenant_accounts[tenant_key].body).accounts, []) : [],
      coalesce(tenant_cfg.include_accounts, [])
    )))
  }
}

Variables
----------
variable "manage_tenants" {
  description = "Set true once Security Lake tables exist and you want to configure subscribers/filters."
  type        = bool
  default     = false
}

Glue_Tables
-----------
# Reference shared Glue tables

###############################################################################
# Glue catalog table references for each shared dataset
###############################################################################

data "aws_glue_catalog_table" "shared" {
  for_each      = var.manage_tenants ? local.active_tables : {}
  provider      = aws.security_lake
  database_name = each.value.database_name
  name          = each.value.table_name
}

Lakeformation_Filters
---------------------
# Lake Formation data filters & grants

###############################################################################
# Lake Formation data filters and grants per tenant
###############################################################################

resource "aws_lakeformation_data_cells_filter" "tenant_scope" {
  for_each = var.manage_tenants ? local.tenant_table_objects : {}
  provider = aws.security_lake

  table_data {
    table_catalog_id = local.table_catalog_id
    database_name    = each.value.database_name
    table_name       = data.aws_glue_catalog_table.shared[each.value.table_key].name
    name             = "filter-${each.value.tenant_key}-${each.value.table_key}"

    column_names = each.value.allowed_columns

    row_filter {
      filter_expression = each.value.row_filter_expression
    }
  }

  depends_on = [
    null_resource.revoke_default_permissions
  ]
}

resource "aws_lakeformation_permissions" "tenant_database_describe" {
  for_each = var.manage_tenants ? local.tenant_database_objects : {}
  provider = aws.security_lake

  catalog_id  = local.catalog_account_id
  principal   = each.value.tenant.query_role_arn
  permissions = ["DESCRIBE"]

  database {
    name = each.value.database_name
  }
}

resource "aws_lakeformation_permissions" "tenant_table_describe" {
  for_each = var.manage_tenants ? local.tenant_table_objects : {}
  provider = aws.security_lake

  catalog_id  = local.catalog_account_id
  principal   = each.value.tenant.query_role_arn
  permissions = ["DESCRIBE"]

  table {
    database_name = each.value.database_name
    name          = each.value.table_name
  }
}

resource "aws_lakeformation_permissions" "tenant_filter_select" {
  for_each = var.manage_tenants ? local.tenant_table_objects : {}
  provider = aws.security_lake

  catalog_id  = local.catalog_account_id
  principal   = each.value.tenant.query_role_arn
  permissions = ["SELECT"]

  data_cells_filter {
    table_catalog_id = local.catalog_account_id
    database_name    = each.value.database_name
    table_name       = each.value.table_name
    name             = aws_lakeformation_data_cells_filter.tenant_scope[each.key].table_data[0].name
  }

  depends_on = [
    aws_lakeformation_data_cells_filter.tenant_scope
  ]
}

Tenant_Tables
-------------
# Build per-tenant table scopes

###############################################################################
# Derive per-tenant table scope (columns + row filters)
###############################################################################

locals {
  tenant_table_matrix = {
    for tenant_key, tenant_cfg in var.tenants :
    tenant_key => {
      for table_key, table_cfg in var.tables :
      table_key => merge(
        {
          allowed_columns = null
          row_filter_expression = length(local.tenant_accounts[tenant_key]) > 0 ? format("accountid IN (%s)", join(", ", [for acct in local.tenant_accounts[tenant_key] : format("'%s'", acct)])) : "accountid IS NULL"
        },
        lookup(
          coalesce(tenant_cfg.table_overrides, {}),
          table_key,
          {
            allowed_columns       = null
            row_filter_expression = null
          }
        )
      )
    }
  }

  tenant_table_pairs = flatten([
    for tenant_key, table_cfg in local.tenant_table_matrix : [
      for table_key, settings in table_cfg : {
        tenant_key            = tenant_key
        tenant                = var.tenants[tenant_key]
        table_key             = table_key
        database_name         = var.tables[table_key].database_name
        table_name            = var.tables[table_key].table_name
        allowed_columns       = lookup(settings, "allowed_columns", null)
        row_filter_expression = lookup(settings, "row_filter_expression", null)
      }
    ]
  ])

  tenant_table_objects = {
    for obj in local.tenant_table_pairs :
    "${obj.tenant_key}::${obj.table_key}" => obj
  }

  tenant_database_groups = {
    for obj in local.tenant_table_pairs :
    "${obj.tenant_key}::${obj.database_name}" => obj...
  }

  tenant_database_objects = {
    for key, objs in local.tenant_database_groups :
    key => {
      tenant_key    = objs[0].tenant_key
      tenant        = objs[0].tenant
      database_name = objs[0].database_name
    }
  }

  active_tables = {
    for table_key, table_cfg in var.tables :
    table_key => table_cfg
    if length([
      for tt in local.tenant_table_pairs : 1
      if tt.table_key == table_key
    ]) > 0
  }
}

Subscribers
-----------
# Create Security Lake subscribers

###############################################################################
# Amazon Security Lake subscribers (one per tenant)
###############################################################################

resource "aws_securitylake_subscriber" "tenant" {
  for_each = var.manage_tenants ? var.tenants : {}
  provider = aws.security_lake

  subscriber_name        = each.key
  subscriber_description = lookup(each.value, "description", null)
  access_type            = "LAKEFORMATION"

  dynamic "source" {
    for_each = each.value.sources != null ? each.value.sources : var.default_security_lake_sources

    content {
      aws_log_source_resource {
        source_name    = source.key
        source_version = source.value
      }
    }
  }

  subscriber_identity {
    principal   = each.value.tenant_account_id
    external_id = each.value.subscriber_external_id
  }

  depends_on = [
    aws_securitylake_data_lake.this,
    aws_lakeformation_data_lake_settings.defaults
  ]

  tags = merge(var.tags, { Tenant = each.key })
}

Lakeformation
-------------
# Lake Formation defaults and cleanup

###############################################################################
# Lake Formation: disable IAMAllowedPrincipals defaults
###############################################################################

resource "aws_lakeformation_data_lake_settings" "defaults" {
  provider   = aws.security_lake
  catalog_id = local.catalog_account_id

  admins = [
    local.security_lake_role
  ]

  parameters = {
    CROSS_ACCOUNT_VERSION = "4"
  }
}

###############################################################################
# Remove IAM_ALLOWED_PRINCIPALS from each shared table
###############################################################################

resource "null_resource" "revoke_default_permissions" {
  for_each = var.manage_tenants ? local.active_tables : {}

  triggers = {
    database = each.value.database_name
    table    = each.value.table_name
  }

  provisioner "local-exec" {
    when    = create
    command = <<-EOT
      set -euo pipefail
      aws lakeformation batch-revoke-permissions --region ${var.home_region} --cli-input-json '{
        "Entries": [{
          "Id": "lf-revoke-${each.key}",
          "Principal": { "DataLakePrincipalIdentifier": "IAM_ALLOWED_PRINCIPALS" },
          "Resource": {
            "Table": {
              "CatalogId": "${local.catalog_account_id}",
              "DatabaseName": "${each.value.database_name}",
              "Name": "${each.value.table_name}"
            }
          },
          "Permissions": ["ALL"],
          "PermissionsWithGrantOption": ["ALL"]
        }]
      }' || echo "No IAM_ALLOWED_PRINCIPALS grant found for ${each.value.database_name}.${each.value.table_name}"
    EOT
  }
}

Inventory_Publishers
--------------------
# OU inventory publisher infrastructure

###############################################################################
# OU inventory publisher (Lambda + EventBridge)
###############################################################################

data "archive_file" "ou_inventory_package" {
  type        = "zip"
  source_dir  = "${path.module}/lambda/tenant_ou_inventory"
  output_path = "${path.module}/build/tenant_ou_inventory.zip"
}

resource "aws_iam_role" "ou_inventory_lambda" {
  provider   = aws.security_lake
  count      = var.manage_tenants ? 1 : 0
  name_prefix = "securitylake-ou-sync-"

  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action    = "sts:AssumeRole"
        Effect    = "Allow"
        Principal = { Service = "lambda.amazonaws.com" }
      }
    ]
  })
}

resource "aws_iam_role_policy" "ou_inventory_lambda" {
  provider = aws.security_lake
  count    = var.manage_tenants ? 1 : 0
  role     = aws_iam_role.ou_inventory_lambda[0].id

  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Sid    = "OrganizationsRead"
        Effect = "Allow"
        Action = [
          "organizations:ListAccountsForParent"
        ]
        Resource = "*"
      },
      {
        Sid    = "WriteInventory"
        Effect = "Allow"
        Action = [
          "s3:PutObject",
          "s3:PutObjectAcl"
        ]
        Resource = [
          local.ou_inventory_objects_arn
        ]
      },
      {
        Sid    = "ListInventoryBucket"
        Effect = "Allow"
        Action = ["s3:ListBucket"]
        Resource = local.ou_inventory_bucket_arn
      },
      {
        Sid    = "Logging"
        Effect = "Allow"
        Action = [
          "logs:CreateLogGroup",
          "logs:CreateLogStream",
          "logs:PutLogEvents"
        ]
        Resource = "*"
      }
    ]
  })
}

resource "aws_cloudwatch_log_group" "ou_inventory_lambda" {
  provider          = aws.security_lake
  count             = var.manage_tenants ? 1 : 0
  name              = "/aws/lambda/${local.ou_inventory_lambda_name}"
  retention_in_days = 30
}

resource "aws_lambda_function" "ou_inventory" {
  provider      = aws.security_lake
  count         = var.manage_tenants ? 1 : 0
  function_name = local.ou_inventory_lambda_name
  role          = aws_iam_role.ou_inventory_lambda[0].arn
  runtime       = "python3.12"
  handler       = "lambda_function.lambda_handler"
  timeout       = 300

  filename         = data.archive_file.ou_inventory_package.output_path
  source_code_hash = data.archive_file.ou_inventory_package.output_sha256

  environment {
    variables = {
      INVENTORY_BUCKET = var.ou_inventory_bucket
      INVENTORY_PREFIX = local.ou_inventory_prefix_clean
      TARGET_OUS       = local.tenant_inventory_target_list
    }
  }

}

# EventBridge rule for Organizations account lifecycle events
resource "aws_cloudwatch_event_rule" "ou_inventory_org_events" {
  provider    = aws.security_lake
  count       = var.manage_tenants ? 1 : 0
  name        = "securitylake-ou-sync-org-events"
  description = "Trigger OU inventory sync when Organization account membership changes."

  event_pattern = jsonencode({
    "source"      : ["aws.organizations"],
    "detail-type" : ["AWS API Call via CloudTrail"],
    "detail" : {
      "eventSource" : ["organizations.amazonaws.com"],
      "eventName" : [
        "CreateAccountResult",
        "InviteAccountToOrganization",
        "MoveAccount",
        "RemoveAccountFromOrganization",
        "CloseAccount"
      ]
    }
  })
}

resource "aws_cloudwatch_event_target" "ou_inventory_org_events" {
  provider = aws.security_lake
  count    = var.manage_tenants ? 1 : 0
  rule      = aws_cloudwatch_event_rule.ou_inventory_org_events[0].name
  target_id = "lambda"
  arn       = aws_lambda_function.ou_inventory[0].arn
}

resource "aws_lambda_permission" "allow_eventbridge_org_events" {
  provider     = aws.security_lake
  count        = var.manage_tenants ? 1 : 0
  statement_id  = "AllowExecutionFromEventBridgeOrg"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.ou_inventory[0].function_name
  principal     = "events.amazonaws.com"
  source_arn    = aws_cloudwatch_event_rule.ou_inventory_org_events[0].arn
}

# Scheduled safety net (daily sync)
resource "aws_cloudwatch_event_rule" "ou_inventory_scheduled" {
  provider            = aws.security_lake
  count               = var.manage_tenants ? 1 : 0
  name                = "securitylake-ou-sync-daily"
  description         = "Daily OU inventory refresh."
  schedule_expression = "rate(1 day)"
}

resource "aws_cloudwatch_event_target" "ou_inventory_scheduled" {
  provider = aws.security_lake
  count    = var.manage_tenants ? 1 : 0
  rule      = aws_cloudwatch_event_rule.ou_inventory_scheduled[0].name
  target_id = "lambda"
  arn       = aws_lambda_function.ou_inventory[0].arn
}

resource "aws_lambda_permission" "allow_eventbridge_schedule" {
  provider     = aws.security_lake
  count        = var.manage_tenants ? 1 : 0
  statement_id  = "AllowExecutionFromEventBridgeSchedule"
  action        = "lambda:InvokeFunction"
  function_name = aws_lambda_function.ou_inventory[0].function_name
  principal     = "events.amazonaws.com"
  source_arn    = aws_cloudwatch_event_rule.ou_inventory_scheduled[0].arn
}

tfvars
-------
# Flip to true after Security Lake tables exist and you want to configure tenants.
manage_tenants = false
