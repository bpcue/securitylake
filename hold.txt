Variable
-----------
###############################################################################
# Input variables
###############################################################################

variable "home_region" {
  description = "Region hosting Security Lake (rollup Region)."
  type        = string
}

variable "organization_management_account_id" {
  description = "AWS Organizations management account ID."
  type        = string
}

variable "organization_management_role_name" {
  description = "Role Terraform assumes in the management account (e.g. OrganizationAccountAccessRole)."
  type        = string
}

variable "security_lake_account_id" {
  description = "Account ID delegated as Amazon Security Lake administrator."
  type        = string
}

variable "security_lake_admin_role_name" {
  description = "Role Terraform assumes inside the Security Lake account."
  type        = string
}

variable "ou_inventory_bucket" {
  description = "S3 bucket containing OU membership JSON documents."
  type        = string
}

variable "create_ou_inventory_bucket" {
  description = "Set to true to let Terraform create and manage the OU inventory S3 bucket."
  type        = bool
  default     = false
}

variable "ou_inventory_prefix" {
  description = "Prefix within the inventory bucket for OU JSON files."
  type        = string
  default     = "ous"
}

variable "default_security_lake_sources" {
  description = "Default log sources to share with each tenant subscriber (source => version)."
  type        = map(string)
  default = {
    CLOUD_TRAIL_MGMT = "2.0"
    VPC_FLOW         = "2.0"
    SH_FINDINGS      = "2.0"
  }
}

variable "tables" {
  description = "Catalog tables to expose (keyed by identifier used in tenant overrides)."
  type = map(object({
    database_name = string
    table_name    = string
  }))
}

variable "tenants" {
  description = <<DESC
Tenant configuration keyed by tenant identifier:
  tenant_account_id        – Account ID that owns the subscriber slot
  subscriber_external_id   – External ID the tenant provides for RAM/resource-link trust
  query_role_arn           – IAM role in the tenant account granted Lake Formation permissions
  ou_id                    – AWS Organizations OU containing tenant member accounts
  description              – Optional description for RAM share
  sources                  – Optional per-tenant source map (defaults to default_security_lake_sources)
  include_accounts         – Optional additional account IDs beyond the OU membership
  table_overrides          – Optional map keyed by var.tables entries with:
                               * allowed_columns (list)
                               * row_filter_expression (PartiQL string)
DESC
  type = map(object({
    tenant_account_id        = string
    subscriber_external_id   = string
    query_role_arn           = string
    ou_id                    = string
    description              = optional(string)
    sources                  = optional(map(string))
    include_accounts         = optional(list(string))
    table_overrides          = optional(map(object({
      allowed_columns       = optional(list(string))
      row_filter_expression = optional(string)
    })))
  }))
}

variable "tags" {
  description = "Tags applied to all provisioned resources."
  type        = map(string)
  default     = {}
}

variable "enable_ou_inventory_lookup" {
  description = "Set true to read tenant OU membership from S3. Leave false to rely solely on include_accounts."
  type        = bool
  default     = false
}


Subscriber
----------
# Create Security Lake subscribers

###############################################################################
# Amazon Security Lake subscribers (one per tenant)
###############################################################################

resource "aws_securitylake_subscriber" "tenant" {
  for_each = var.tenants
  provider = aws.security_lake

  subscriber_name        = each.key
  subscriber_description = lookup(each.value, "description", null)
  access_type            = "LAKEFORMATION"

  dynamic "source" {
    for_each = each.value.sources != null ? each.value.sources : var.default_security_lake_sources

    content {
      aws_log_source_resource {
        source_name    = source.key
        source_version = source.value
      }
    }
  }

  subscriber_identity {
    principal   = each.value.tenant_account_id
    external_id = each.value.subscriber_external_id
  }

  depends_on = [
    aws_securitylake_data_lake.this,
    aws_lakeformation_data_lake_settings.defaults
  ]

  tags = merge(var.tags, { Tenant = each.key })
}

Inventory
---------
# Load OU inventory from S3

###############################################################################
# Tenant OU inventory – read pre-generated JSON from S3
###############################################################################

locals {
  tenant_s3_objects = var.enable_ou_inventory_lookup ? {
    for tenant_key, tenant_cfg in var.tenants :
    tenant_key => {
      bucket = var.ou_inventory_bucket
      key    = local.ou_inventory_prefix_clean != "" ? "${local.ou_inventory_prefix_clean}/${tenant_cfg.ou_id}.json" : "${tenant_cfg.ou_id}.json"
    }
  } : {}
}

data "aws_s3_object" "tenant_accounts" {
  for_each = var.enable_ou_inventory_lookup ? local.tenant_s3_objects : {}
  provider = aws.security_lake
  bucket   = each.value.bucket
  key      = each.value.key
}

locals {
  tenant_accounts = {
    for tenant_key, tenant_cfg in var.tenants :
    tenant_key => sort(distinct(concat(
      var.enable_ou_inventory_lookup ? try(jsondecode(data.aws_s3_object.tenant_accounts[tenant_key].body).accounts, []) : [],
      coalesce(tenant_cfg.include_accounts, [])
    )))
  }
}
